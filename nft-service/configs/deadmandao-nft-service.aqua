-- pull in the standard Aqua definitions
import "@fluencelabs/aqua-lib/builtin.aqua"

-- hard code the PEER_ID and SERVICE_ID for convenience
-- not a good idea for production code, but handy for development
-- of a demo application
const PEER_ID ?= "12D3KooWDUszU2NeWyUVjCXhGEt1MoZrhvdmaQQwtZUriuGN1jTr"
const SERVICE_ID ?= "d305388a-61b2-446f-805d-71465695b822"

-- definition to match the Rust struct, generated by "marine aqua"
data Item:
  id: string
  token_id: string
  marketplace: string
  blockchain: string
  name: string
  description: string
  detail_url: string
  image_url: string

-- definition to match the Rust struct, generated by "marine aqua"
data ItemPage:
  marketplace: string
  opensea_next_offset: i32
  rarible_continuation: string
  items: []Item

-- definition to match the Rust struct, generated by "marine aqua"
data ItemPages:
  opensea_page: ItemPage
  rarible_page: ItemPage

-- definition to match the Rust functions, generated by "marine aqua"
service DeadmandaoService:
  collect_these(opensea_page: ItemPage, rarible_page: ItemPage) -> ItemPages
  download(url: string) -> string
  get_first_opensea_page() -> ItemPage
  get_first_rarible_page() -> ItemPage
  get_opensea_continuation(opensea_next_offset: i32) -> ItemPage
  get_rarible_continuation(rarible_continuation: string) -> ItemPage

-- simple pass-through to the Rust function
func download(url: string) -> string:
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    reslt <- DeadmandaoService.download(url)
  <- reslt

-- simple pass-through to the Rust function
func get_first_opensea_page() -> ItemPage:
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    page <- DeadmandaoService.get_first_opensea_page()
  <- page

-- simple pass-through to the Rust function
func get_first_rarible_page() -> ItemPage:
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    page <- DeadmandaoService.get_first_rarible_page()
  <- page

-- simple pass-through to the Rust function
func get_opensea_continuation(opensea_next_offset: i32) -> ItemPage:
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    page <- DeadmandaoService.get_opensea_continuation(opensea_next_offset)
  <- page

-- simple pass-through to the Rust function
func get_rarible_continuation(rarible_continuation: string) -> ItemPage:
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    page <- DeadmandaoService.get_rarible_continuation(rarible_continuation)
  <- page

-- this function hints at the real strenght of Aqua.
-- Having deployed and tested individual functions using
-- the simple pass-through calls above, we can now compose
-- those functions into a new process flow. In this case,
-- we make parallel calls to the two initial page requests,
-- one for OpenSea and one for Rarible. No changes were
-- needed to the Rust code and the WASM did not need to be
-- redeployed. This kind of service recomposition can be
-- done entirely by the consumer of the services.
func get_first_pages() -> ItemPages:
  -- make a background call to get_first_opensea_page()
  co on PEER_ID:
    DeadmandaoService SERVICE_ID
    opensea_page <- DeadmandaoService.get_first_opensea_page()
  -- make a background call, in parallel, to get_frist_rarible_page()
  co on PEER_ID:
    DeadmandaoService SERVICE_ID
    rarible_page <- DeadmandaoService.get_first_rarible_page()
  -- wait until we have a value for for both pages
  join opensea_page, rarible_page
  -- set a reasonable timeout in case one or both calls stall
  -- Note: I am not handling errors correctly here. I think
  -- that is why I am getting inconsistent failures. I have
  -- a lot to learn about Aqua, but this quick experience has
  -- shown that the potential is worth exploring further.
  par Peer.timeout(5000, "timeout")
  -- When we have values for both pages, use the tiny Rust
  -- function that puts them into a struct that Javascript
  -- can handle.
  on PEER_ID:
    DeadmandaoService SERVICE_ID
    pages <- DeadmandaoService.collect_these(opensea_page, rarible_page)
  <- pages

